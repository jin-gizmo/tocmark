#!/bin/sh
# ex: ft=awk ts=4 sw=4 ai et cc=80

# Some magic here -- we need a lines that are syntactically valid in shell and
# awk and which will be executed in shell and _not_ executed in awk. Oh yes, and
# we must navigate the vagaries of Alpine, Ubuntu, Fedora and macOS sects.
true && "[" "$1" "=" "-v" "]" && exec awk -f "$0" "-v" "print_version=1"
true && exec awk -f "$0" "$@"

# ------------------------------------------------------------------------------
# AWK script from here on down.
BEGIN {
    VERSION = "1.0.0"
    REPO = "https://github.com/jin-gizmo/tocmark"
    LineCount = 0
    ExitStatus = -1
    MinLevel = 1            # Default minimum heading level
    MaxLevel = 3            # Default maximum heading level
    DefaultMark = "&bull;"  # Default list item marker in compact mode
    split("", Content)      # line num -> text
    split("", Anchor)       # index -> anchor text
    split("", TocText)      # index -> text (Displayed in TOC)
    split("", HeadingLevel) # index -> heading level
    split("", AnchorSet)    # For deduplicating anchors.
    InCodeBlock = 0
    InToc = 0

    if (print_version) {
        print VERSION
        ExitStatus = 0
        exit
    }
}

# ------------------------------------------------------------------------------
function trim(s) { gsub(/^[[:space:]]+|[[:space:]]+$/, "", s); return s }

function stderr(s) { print s | "cat 1>&2"; close("cat 1>&2") }

function abort(s) { stderr(s); ExitStatus = 1; exit 1 }

# Repeat string s n times.
function repeat(s, n,    i, str) {
    str = ""
    for (i = 0; i < n; i++) str = str s
    return str
}

function github_anchor(text,    anchor) {
    anchor = tolower(text)
    gsub(/ /, "-", anchor)
    gsub(/[^-a-z0-9_]/, "", anchor)
    return anchor
}

# GitHub adds -1, -2 etc to disambiguate repeated headings so we need to keep
# track of anchors already created.
function unique_anchor(text,     base, anchor, n) {
    base = github_anchor(text)
    anchor = base
    while (anchor in AnchorSet) anchor = base "-" ++n
    AnchorSet[anchor] = 1
    return anchor
}

# Print a table of contents using a Markdown list.
function print_toc_md_list(params,    min_level, max_level, i, hlevel, suppress_level) {
    min_level = params["min"]
    max_level = params["max"]
    suppress_level = 9999 # If we suppress a heading, its children also suffer.
    for (i = 1; i <= length(HeadingLevel); i++) {
        hlevel = HeadingLevel[i]
        if (hlevel > suppress_level) continue
        suppress_level = 9999
        if (TocText[i] == "") {
            suppress_level = hlevel
            continue
        }
        if (hlevel < min_level || hlevel > max_level) continue
        printf "%" (hlevel - min_level) * 4 "s*   [%s](#%s)\n\n", "", TocText[i], Anchor[i]
    }
}

# Print a more compact TOC using HTML divs.
function print_toc_compact(params,    min_level, max_level, i, hlevel, suppress_level, spaces, mark) {
    min_level = params["min"]
    max_level = params["max"]
    mark = (params["mark"] != "") ? params["mark"] : DefaultMark
    if (match(mark, /^&[^;]+$/)) mark = mark ";"  # Fix missing ; on HTML codes
    suppress_level = 9999
    for (i = 1; i <= length(HeadingLevel); i++) {
        hlevel = HeadingLevel[i]
        if (hlevel > suppress_level) continue
        suppress_level = 9999
        if (TocText[i] == "") {
            suppress_level = hlevel
            continue
        }
        if (hlevel < min_level || hlevel > max_level) continue
        spaces = repeat("&nbsp;", (hlevel - min_level) * 4)
        printf "<div>%s%s <a href=\"#%s\">%s</a></div>\n", spaces, mark, Anchor[i], TocText[i]
    }
    print "<p></p>"
}

# Print a linear, delineated TOC. This really only makes sense when a single
# level of headings is included.
function print_toc_linear(params,    to_print, min_level, max_level, i, hlevel, suppress_level, txt, sep, mark) {
    min_level = params["min"]
    max_level = params["max"]
    mark = (params["mark"] != "") ? params["mark"] : DefaultMark
#    if (match(mark, /^&[^;]+$/)) mark = mark ";"  # Fix missing ; on HTML codes
    suppress_level = 9999 # If we suppress a heading, its children also suffer.
    split("", to_print)
    # Work out what to print
    for (i = 1; i <= length(HeadingLevel); i++) {
        hlevel = HeadingLevel[i]
        if (hlevel > suppress_level) continue
        suppress_level = 9999
        if (TocText[i] == "") {
            suppress_level = hlevel
            continue
        }
        if (hlevel < min_level || hlevel > max_level) continue
        txt = TocText[i]
        gsub(/[[:space:]]+/, "\\&nbsp;", txt)
        to_print[length(to_print) + 1] = sprintf("[%s](#%s)", txt, Anchor[i])
    }
    # Now print it
    for (i = 1; i <= length(to_print); i++) {
        sep = (i < length(to_print)) ? " " mark : ""
        print to_print[i] sep
    }
}

# Parse HTML-style parameters: key=value or key="value" or key='value'. Multiple
# parameters are separated by whitespace. Returns the number of parameters found.
function parse_params(s, arr,    content, key, val, pcount) {
    split("", arr)
    if (!match(s, /<!--.*-->/)) return 0

    # Extract content between <!-- and --> and remove directive (first word).
    content = substr(s, RSTART + 4, RLENGTH - 7)
    content = trim(content)
    sub(/^[-a-zA-Z0-9_]+[[:space:]]*/, "", content)

    # Parse key=value pairs (whitespace-delimited)
    while (length(content) > 0) {
        # Skip leading whitespace
        sub(/^[[:space:]]+/, "", content)
        if (length(content) == 0) break

        # Match key=value patterns and extract the key
        if (!match(content, /^[a-zA-Z0-9_]+[[:space:]]*=/)) break
        key = substr(content, RSTART, RLENGTH)
        sub(/[[:space:]]*=$/, "", key)
        content = substr(content, RLENGTH + 1)

        if (match(content, /^('[^']*'|"[^"]*")/)) {
            # Quoted value
            val = substr(content, 2, RLENGTH - 2)
            content = substr(content, RLENGTH + 1)
        } else if (match(content, /^[[:space:]]/)) {
            # Whitespace immediately after = means empty value.
            val = ""
            # Don't consume the whitespace - leave it for next iteration
        } else if (match(content, /^[^[:space:]]+/)) {
            # Unquoted value
            val = substr(content, RSTART, RLENGTH)
            content = substr(content, RLENGTH + 1)
        } else {
            # End of string after =
            val = ""
        }

        arr[key] = val
        pcount++

    }
    return pcount
}

# For debugging -- print array contents
#function aprint(heading, array,    k, key) {
#    stderr(heading ":")
#    for (k in array) {
#        key = k
#        gsub(SUBSEP, ", ", key)
#        stderr("    (" key ") = \"" array[k] "\"")
#    }
#    stderr("-----------")
#}

# ------------------------------------------------------------------------------
!InToc { Content[++LineCount] = $0 }

/^```/ { InCodeBlock = (InCodeBlock) ? 0 : NR }
InCodeBlock { next }

# ------------------------------------------------------------------------------
# TOC start marker
/<!--[[:space:]]*toc-start([[:space:]]*|[[:space:]]+.*)-->$/ {
    if (InToc) abort("Nested TOC start marker on line " NR)
    InToc = NR
}
# TOC end marker
/<!--[[:space:]]*toc-end[[:space:]]*-->/ {
    if (!InToc) abort("Unexpected TOC end marker on line " NR)
    InToc = 0
    Content[++LineCount] = $0
    next
}

InToc { next }

# ------------------------------------------------------------------------------
# Capture headings
$1 ~ /^#+$/ && !/<!--[[:space:]]*no-toc[[:space:]]*-->/ {
    idx = length(HeadingLevel) + 1
    HeadingLevel[idx] = length($1)
    sub(/^[^[:space:]]+[[:space:]]*/, "")  # Remove $1 to get heading content
    sub(/[[:space:]]+$/, "")    # Remove trailing whitespace
    sub(/[[:space:]]*#+$/, "")  # Remove trailing heading marker
    gsub(/<!--[^>]*-->/, "")    # Remove any embedded HTML comments
    Anchor[idx] = unique_anchor($0)
    gsub(/[[:space:]]{2,}/, " ") # Collapse multiple spaces to 1 in display text
    TocText[idx] = trim($0)
}

# TOC override for previous heading : <!-- toc text="Alternate Heading" -->
# If the alternate heading is empty, the heading (and its children) will be
# excluded from the TOC.
/<!--[[:space:]]*toc([[:space:]]*|[[:space:]]+.*)-->$/ {
    if (length(HeadingLevel) == 0) abort("toc directive on line " NR " with no preceding heading")
    parse_params($0, params)
    if (length(params) == 0) abort("toc directive on line " NR " with no parameters")
    if ("text" in params) TocText[length(TocText)] = params["text"]
}

# ------------------------------------------------------------------------------
END {
    if (ExitStatus >= 0) exit ExitStatus
    if (InToc) abort("Unclosed TOC section that opened on line " InToc)
    if (InCodeBlock) abort("Unclosed code block that opened on line " InCodeBlock)

    InCodeBlock = 0
    for (line_no = 1; line_no <= length(Content); line_no++) {
        line = Content[line_no]
        print line
        if (line ~ /^```/) InCodeBlock = !InCodeBlock
        if (!InCodeBlock && line ~ /<!--[[:space:]]*toc-start([[:space:]]*|[[:space:]]+.*)-->$/) {
            print ("<!-- Generated by TOCmark (" REPO ") -->")
            print ""
            parse_params(line, params)
            if (params["min"] + 0 == 0) params["min"] = MinLevel
            if (params["max"] + 0 == 0) params["max"] = MaxLevel
            if (params["style"] == "compact")
                print_toc_compact(params)
            else if (params["style"] == "linear")
                print_toc_linear(params)
            else
                print_toc_md_list(params)
            print ""
        }
    }
}
